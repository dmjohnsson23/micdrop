"""
Micdrop extension to use a set of ANX files as a source. The inverse (using ANX files as a sink)
is not supported or intended.

ANX files, also known as "Answer Files", are data files generated by HotDocs, Lexis Nexis, and 
possibly other applications. They appear to more or less be sets of autofill values used to 
populate template documents. It is an XML-based format that forms a set of key/value pairs called
"Answers".
"""
from ..pipeline import Source
from dateutil.parser import parse as parse_date
from xml.etree.ElementTree import Element, parse, tostring
from typing import Iterable
from decimal import Decimal

class AnxSource(Source):
    """
    Source to pull data from a collection of HotDocs "Answer Files".

    * `TextValue` is read as `str`
    * `NumValue` is read as `Decimal`
    * `DateValue` is read as `datetime`
    * `TFValue` is read as `bool`
    * `MCValue` is read as `List[str]`
    * `ClauseLibValue` is read as `List[dict]`
    * `DBValue` is read as `List[Any]`
    * `RptValue` is read as `List[Any]`
    * `DocTextValue` is read as `str`, and will contain RTF data that can be converted using `PandocConvert`
    """
    _answers:dict
    _meta:dict
    _filenames:Iterable[str]
    _current_filename:str

    def __init__(self, filenames:Iterable[str]):
        self._filenames = iter(filenames)

    def _parse_file(self, file):
        """
        Parse the ANX file into a dictionary.

        The ANX file follows the following DTD format, as extracted from the DOCTYPE of an ANX file:

        ```dtd
        <!ELEMENT AnswerSet (Answer*)>
        <!ELEMENT Answer (TextValue | NumValue | DateValue | TFValue | MCValue | ClauseLibValue | DBValue | RptValue | DocTextValue)>

        <!-- While the DTD allows DBValue in nested repeats, the current implementation does not. -->
        <!ELEMENT RptValue (TextValue* | NumValue* | DateValue* | TFValue* | MCValue* | ClauseLibValue* | DBValue* | RptValue*)>

        <!ELEMENT TextValue      (#PCDATA)         >
        <!ELEMENT NumValue       (#PCDATA)         >
        <!ELEMENT DateValue      (#PCDATA)         >
        <!ELEMENT TFValue        (#PCDATA)         >
        <!ELEMENT DocTextValue   (#PCDATA)         >
        <!ELEMENT MCValue        (SelValue*)       >
        <!ELEMENT ClauseLibValue (ClauseSelValue*) >
        <!ELEMENT DBValue        (DBColumn*)       >

        <!ELEMENT DBColumn (TextValue | NumValue | DateValue | TFValue | MCValue)>
        <!ELEMENT SelValue       (#PCDATA)         >
        <!ELEMENT ClauseSelValue  EMPTY            >

        <!ATTLIST AnswerSet
            title   CDATA #IMPLIED
            version CDATA #REQUIRED
            save (true | false | nochange) #IMPLIED
            useMangledNames (true | false) #IMPLIED>

        <!-- The name attribute of an Answer element is the name of the component it maps to. -->
        <!ATTLIST Answer
            name CDATA #REQUIRED
            save (true | false | nochange) #IMPLIED>

        <!ATTLIST TextValue      unans (true | false) #IMPLIED>
        <!ATTLIST NumValue       unans (true | false) #IMPLIED>
        <!ATTLIST DateValue      unans (true | false) #IMPLIED>
        <!ATTLIST TFValue        unans (true | false) #IMPLIED>
        <!ATTLIST MCValue        unans (true | false) #IMPLIED>
        <!ATTLIST ClauseLibValue unans (true | false) #IMPLIED>
        <!ATTLIST ClauseSelValue
            title       CDATA   #REQUIRED
            fileName    CDATA   #REQUIRED
            description CDATA   #IMPLIED>
        <!ATTLIST DBValue        unans (true | false) #IMPLIED>
        <!ATTLIST DBColumn name CDATA #REQUIRED>

        <!-- Only rtf is supported for fmt below. However, other formats are included for possible future support. -->
        <!ATTLIST DocTextValue
            fmt    (rtf | txt | wp6 | unk)  #REQUIRED
            unans  (true | false)           #IMPLIED>
        ```
        """
        document = parse(file)
        meta = document.getroot().attrib
        answers = {}
        for answer_el in document.findall('Answer'):
            key = answer_el.get('name')
            value = self._parse_value(answer_el.find('./*'))
            answers[key] = value
        return meta, answers
    
    def _parse_value(self, value:Element):
        if value.get('unans') == 'true':
            return None
        if value.tag == 'TextValue':
            return value.text
        if value.tag == 'NumValue':
            # While example files I've seen always ues integer values, those values appear to 
            # always be in a fixed-precision decimal format, e.g. "10.0000000"
            return Decimal(value.text)
        if value.tag == 'DateValue':
            # Date format seems to be d/m/yyyy (day and month not padded with zeros)
            # datetime.strptime won't work because of non-padded numbers.
            return parse_date(value.text, dayfirst=True)
        if value.tag == 'TFValue':
            if value.text == 'true':
                return True
            if value.text == 'false':
                return False
        if value.tag == 'MCValue':
            return [sel.text for sel in value.findall('SelValue')]
        if value.tag == 'ClauseLibValue':
            return [sel.attrib for sel in value.findall('ClauseSelValue')]
        if value.tag == 'DBValue':
            return [self._parse_value(val) for val in value.findall('DBColumn/*')]
        if value.tag == 'RptValue':
            return [self._parse_value(val) for val in value.findall('./*')]
        if value.tag == 'DocTextValue':
            # TODO should we try to automatically parse this into a more usable format? Or leave that to the user?
            # rtf - I created a pandoc extension that should be able to deal with this
            # txt - would require no transformation
            # I'm not familiar with the other two formats. And neither is pandoc.
            # "wp6" might be a markdown-like format used by WhatsApp? Or something related to WordPress?
            # Since the DTD suggests only RTF is supported right now anyway, I'll defer this.
            return value.text
        raise ValueError(f'Failed to parse answer value: """{tostring(value)}"""')
    
    def next(self):
        super().next()
        self._meta = None
        self._answers = None
        self._current_filename = next(self._filenames)
    
    def get(self):
        if self._answers is None:
            self._meta, self._answers = self._parse_file(self._current_filename)
        return self._answers
    
    def get_index(self):
        return self._current_filename
    
    def get_meta(self):
        if self._meta is None:
            self._meta, self._answers = self._parse_file(self._current_filename)
        return self._meta